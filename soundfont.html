<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Nextapps JS-Synthesizer MIDI Player (CDN)</title>
  <style>
    body { font-family: sans-serif; text-align: center; margin: 20px; }
    .file-input-group { margin-bottom: 10px; }
    label { display: inline-block; width: 120px; text-align: right; margin-right: 5px; }
    button { padding: 10px 15px; font-size: 16px; cursor: pointer; margin-top: 10px; margin-left: 5px; }
    #status { margin-top: 15px; font-weight: bold; min-height: 20px; }
    small { display: block; margin-top: 20px; color: #555; }
  </style>
</head>
<body>
  <h1>Nextapps JS-Synthesizer MIDI Player</h1>

  <div class="file-input-group">
    <label for="sf2Input">SoundFont (.sf2):</label>
    <input type="file" id="sf2Input" accept=".sf2">
  </div>

  <div class="file-input-group">
    <label for="midiInput">MIDI (.mid, .midi):</label>
    <input type="file" id="midiInput" accept=".mid,.midi">
  </div>

  <button id="playBtn" disabled>再生</button>
  <button id="stopBtn" disabled>停止</button>

  <div id="status">ライブラリをCDNから読み込み中...</div>
  <small>
    使用ライブラリ: nextapps-de/js-synthesizer (CDN経由)<br>
    インターネット接続が必要です。
  </small>

  <script src="https://cdn.jsdelivr.net/npm/js-synthesizer@1.10.0/externals/libfluidsynth-2.3.0.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/js-synthesizer@1.10.0/dist/js-synthesizer.min.js"></script>

  <script>
    const sf2Input = document.getElementById('sf2Input');
    const midiInput = document.getElementById('midiInput');
    const playBtn = document.getElementById('playBtn');
    const stopBtn = document.getElementById('stopBtn');
    const statusDiv = document.getElementById('status');

    let audioContext = null;
    let synthesizer = null;
    let audioNode = null;

    let sfontBuffer = null;
    let midiBuffer = null;
    let isPlaying = false;

    // AudioContextをユーザー操作時に再開する関数
    function resumeAudioContext() {
      if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
          console.log('AudioContext resumed successfully by user gesture.');
        }).catch(e => console.error('Error resuming AudioContext:', e));
      }
    }
    // 最初のユーザー操作でAudioContextをアクティブにする
    document.body.addEventListener('click', resumeAudioContext, { once: true });


    async function initializeSynthesizer() {
      statusDiv.textContent = "ライブラリ準備待機中...";
      try {
        // JSSynth オブジェクトがグローバルに存在することを確認
        if (typeof JSSynth === 'undefined' || typeof JSSynth.waitForReady !== 'function') {
            await new Promise(resolve => setTimeout(resolve, 500)); // 少し待つ
            if (typeof JSSynth === 'undefined' || typeof JSSynth.waitForReady !== 'function') {
                 throw new Error("JS-Synthesizerライブラリが正しく読み込まれていません。");
            }
        }

        await JSSynth.waitForReady();
        statusDiv.textContent = "ライブラリ準備完了。シンセサイザー初期化中...";

        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        // ユーザー操作による再開を促す
        if (audioContext.state === 'suspended') {
            statusDiv.textContent += " (オーディオ再開のためページをクリックしてください)";
        }
        
        synthesizer = new JSSynth.Synthesizer();
        await synthesizer.init(audioContext.sampleRate); // initはPromiseを返す

        // オーディオノードを作成して接続 (バッファサイズはデフォルトまたは適切な値に)
        const bufferSize = 8192; 
        audioNode = synthesizer.createAudioNode(audioContext, bufferSize);
        if (!audioNode) throw new Error("AudioNodeの作成に失敗しました。");
        audioNode.connect(audioContext.destination);

        statusDiv.textContent = "シンセサイザー初期化完了。SoundFontとMIDIファイルを選択してください。";
        enableFileInputs();

      } catch (error) {
        console.error("初期化エラー:", error);
        statusDiv.textContent = `初期化エラー: ${error.message}`;
        disableAllControls();
      }
    }

    function enableFileInputs() {
      sf2Input.disabled = false;
      midiInput.disabled = false;
    }

    function disableAllControls() {
      sf2Input.disabled = true;
      midiInput.disabled = true;
      playBtn.disabled = true;
      stopBtn.disabled = true;
    }
    
    function updatePlayButtonState() {
        playBtn.disabled = !(sfontBuffer && midiBuffer && synthesizer && !isPlaying);
        stopBtn.disabled = !isPlaying;
    }

    sf2Input.addEventListener('change', async function(event) {
      const file = event.target.files[0];
      if (!file || !synthesizer) {
        sfontBuffer = null;
        updatePlayButtonState();
        return;
      }
      statusDiv.textContent = `SoundFont「${file.name}」をロード中...`;
      try {
        const buffer = await file.arrayBuffer();
        await synthesizer.loadSFont(buffer);
        sfontBuffer = buffer; // ロード成功したら保持（再利用はできないが、ロード済みフラグとして）
        statusDiv.textContent = `SoundFont「${file.name}」ロード完了。`;
        console.log("SoundFont loaded.");
      } catch (error) {
        console.error("SoundFontロードエラー:", error);
        statusDiv.textContent = `SoundFontロードエラー: ${error.message}`;
        sfontBuffer = null;
      }
      updatePlayButtonState();
    });

    midiInput.addEventListener('change', async function(event) {
      const file = event.target.files[0];
      if (!file) {
        midiBuffer = null;
        updatePlayButtonState();
        return;
      }
      statusDiv.textContent = `MIDIファイル「${file.name}」を読み込み中...`;
      try {
        midiBuffer = await file.arrayBuffer(); // MIDIデータは再生時に渡すので保持
        statusDiv.textContent = `MIDIファイル「${file.name}」ロード完了。`;
        console.log("MIDI file loaded.");
      } catch (error) {
        console.error("MIDIファイルロードエラー:", error);
        statusDiv.textContent = `MIDIファイルロードエラー: ${error.message}`;
        midiBuffer = null;
      }
      updatePlayButtonState();
    });

    playBtn.addEventListener('click', async function() {
      if (!sfontBuffer || !midiBuffer || !synthesizer) {
        statusDiv.textContent = "SoundFontまたはMIDIファイルがロードされていません。";
        return;
      }
      if (isPlaying) return;

      resumeAudioContext(); // 再生前にAudioContextの状態を確認・再開

      try {
        isPlaying = true;
        updatePlayButtonState();
        statusDiv.textContent = "MIDIデータをプレイヤーに追加中...";
        
        // 既存の再生データがあればクリアする機能は見当たらないため、
        // 再生毎にaddSMFDataToPlayerを呼ぶ。
        // ライブラリの挙動によっては、stopPlayer後に再度addする必要があるか確認要。
        // このAPIでは、playerは内部的なもののようで、SMFデータを追加して再生する形。
        await synthesizer.addSMFDataToPlayer(midiBuffer);
        statusDiv.textContent = "再生開始...";
        await synthesizer.playPlayer();
        statusDiv.textContent = "再生中...";

        // 再生終了を待つ
        await synthesizer.waitForPlayerStopped();
        // waitForPlayerStoppedの後に呼ばれるので、これが再生終了のタイミング
        console.log("Playback finished.");
        statusDiv.textContent = "再生終了。";
        isPlaying = false;
        updatePlayButtonState();

      } catch (error) {
        console.error("再生エラー:", error);
        statusDiv.textContent = `再生エラー: ${error.message}`;
        isPlaying = false;
        updatePlayButtonState();
      }
    });

    stopBtn.addEventListener('click', async function() {
      if (!synthesizer || !isPlaying) return;
      try {
        await synthesizer.stopPlayer(); // 停止
        console.log("Playback stopped by user.");
        statusDiv.textContent = "停止しました。";
      } catch (error) {
        console.error("停止エラー:", error);
        statusDiv.textContent = `停止エラー: ${error.message}`;
      } finally {
        isPlaying = false;
        updatePlayButtonState();
      }
    });

    // 初期化処理を開始
    sf2Input.disabled = true; // 初期は無効
    midiInput.disabled = true;
    initializeSynthesizer();

  </script>
</body>
</html>
