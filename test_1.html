<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Tone.js 再生・停止テンプレ</title>
  <script src="https://unpkg.com/tone@latest/build/Tone.js"></script>
</head>
<body>
  <h2>再生・停止</h2>
  <button id="startBtn">▶ スタート</button>
  <button id="stopBtn">■ ストップ</button>

  <script>
    let count = 0;
    let chord_count=0;

    // シンセ用意
    const limiter = new Tone.Limiter(-6).toDestination();
    const compressor = new Tone.Compressor({
  threshold: -24, // dB 単位のしきい値。入力レベルがこの値を超えると圧縮開始
  ratio: 10,       // 圧縮比（例:4 ＝ 4:1）。入力がしきい値を 4dB 超過すると、出力は 1dB 超過の扱いに
  attack: 0.003,  // アタックタイム（秒）。しきい値超過後に圧縮がかかり始めるまでの時間
  release: 0.250, // リリースタイム（秒）。圧縮をかけた後、元のゲインに戻るまでの時間
  knee: 20        // ニー（dB）。この範囲内で徐々に圧縮がかかる。0 ならハードニー。
}).connect(limiter);

// 1) Reverb を生成し、wet を 0.5 に初期設定
const reverb = new Tone.Reverb({
     decay: 2.5,      // 残響（リバーブ）時間（秒）
     preDelay: 0.1,  // 初期遅延（秒）
     wet: 0.1  // 初期値としてドライ&ウェット 50:50
    }).connect(compressor);
    
const fbDelay = new Tone.FeedbackDelay({
  delayTime: "8n", // 遅延時間（四分音符 1 拍）
  feedback: 0.2,   // フィードバック比率（0～1）
  wet: 0.1         // ドライ/ウェット比（0.0～1.0）
}).connect(reverb);

const master_bus = new Tone.Channel().connect(fbDelay);
    
const sample = new Tone.Players({
  kick: "dance_kick_2.wav",
  snare: "clap snare.wav",
  hh: "closed_hihat_808.wav"

}).connect(compressor);
sample.autostart = false; // 自動再生はしない

// PolySynth を作成し、★MonoSynth のパラメータをオブジェクトで指定★
    
const synth = new Tone.PolySynth(Tone.MonoSynth, {
  // ── MonoSynth のオシレーター設定 ──
  maxPolyphony:24,
  oscillator: {
    type: "sawtooth",   // 'sine' / 'square' / 'triangle' / 'sawtooth' など
  },
  // ── MonoSynth のフィルター設定（必要に応じて） ──
  filter: {
    type: "lowpass",
    Q: 0.1,
    rolloff: -12
  },
  // ── MonoSynth のエンベロープ（音量エンベロープ） ──
  envelope: {
    attack: 0.02,
    decay: 0.05,
    sustain: 0.7,
    release: 0.05
  },
  // ── フィルターエンベロープ（必要な場合） ──
  filterEnvelope: {
    attack: 0.01,
    decay: 0.1,
    sustain: 0.8,
    release: 0.1,
    baseFrequency: 4000,
    octaves: 2
  }
}).connect(master_bus);

    
    // ループ：四分音符ごとに音を鳴らす
    const loop = new Tone.Loop((time) => {
      console.log("count:", count);

      const chords2 = [
  ["F3", "A3", "C4", "E4"],
  ["F3", "A3", "C4", "E4"],
  ["F3", "A3", "C4", "E4"],
  ["F3", "A3", "C4", "E4"],
        
  ["C3", "E3", "G3", "D4"],
  ["C3", "E3", "G3", "D4"],
  ["C3", "E3", "G3", "D4"],
  ["C3", "E3", "G3", "D4"],
        
  ["G2", "G3", "B3", "D4"],
  ["G2", "G3", "B3", "D4"],
  ["G#2","G#3","B3", "D4"],        
  ["G#2","G#3","B3", "D4"],
        
  ["A2", "G3", "C4", "E4"],      
  ["A2", "G3", "C4", "E4"],
  ["A2", "G3", "C4", "E4"],      
  ["A2", "G3", "C4", "E4"]
];
  
      const chords = [
  ["F2", "C3", "G4"],
  ["F2", "C3", "G4"],
  ["F2", "A3", "C4", "E4"],
  ["F2", "A3", "C4", "E4"],
  
  ["G2", "G3", "B3", "G4"],  
  ["G2", "G3", "B3", "G4"],
        
  ["G2", "D3", "C4", "E4"],
  ["G2", "D3", "C4", "E4"],
        
  ["A2", "A3", "C4", "B4"],
　 ["A2", "A3", "C4", "B4"],
        
  ["A2", "E3","E4", "G4"],
  ["A2", "E3","E4", "G4"],
        
  ["A2", "E3", "A3", "E4","A4"],   
  ["A2", "E3", "A3", "E4","A4"],   
  ["A2", "C4", "G4"],
  ["A2", "C4", "G4","E4"]
];
      
 const melos = [
  
  "C5", "D5", "E5", "C5",
  "D5", "E5", "G5", "D5",
  "C5", "D5", "E5", "G5",
  "E5", "D5", "C5", "A4"
];

const patterns = {
  kick:  [1, 0, 1, 0,  0,  0, 0, 0,
          0, 0, 1, 0,  0,  0, 0, 0],
  snare: [0, 0, 0, 0,  1,  0, 0, 0,
          0, 0, 0, 0,  1,  0, 0, 0],
  hh:    [1, 1, 1, 1,  1,  1, 1, 1,
          1, 1, 1, 1,  1,  1, 1, 1]
};


     let chord;

     if(chord_count<4){
       chord = chords[(count/2) % chords.length];
     }else{
        chord = chords2[(count/2) % chords.length];
     }
     const melo = melos[(count/2) % melos.length];
     
   
 
    synth.triggerAttackRelease(chord, "8n", time,0.6);
     
     
     synth.triggerAttackRelease(melo, "16n", time,0.3);

      if (patterns.kick[count%16]) {
        sample.player("kick").start(time);
      }
      if (patterns.snare[count%16]) {
        sample.player("snare").start(time);
      }
      if (patterns.hh[count%16]) {
        sample.player("hh").start(time);
      }
    
      count++;
      count=count%64;
      if(count==0){
        chord_count++;  
        chord_count=chord_count%8;
      }
    }, "16n");
    


    // スタートボタン
    document.getElementById("startBtn").addEventListener("click", async () => {
      await Tone.start();  // AudioContext を起動
      Tone.Transport.bpm.value = 160;

      count = 0;           // カウント初期化
      loop.start(0);       // ループ開始
      Tone.Transport.start();  // タイムライン再生
    });

    // ストップボタン
    document.getElementById("stopBtn").addEventListener("click", () => {
      loop.stop();         // ループ停止
      Tone.Transport.stop();   // タイムライン停止
      Tone.Transport.cancel(); // スケジュールもリセット（任意）
      console.log("Stopped");
    });
  </script>
</body>
</html>

